#!/usr/bin/env python3
"""
GROMACS PCA automation script

This script automates a typical Principal Component Analysis (PCA) workflow
for MD trajectories using GROMACS tools and produces Matplotlib plots.

Pipeline (default):
1) Build an index using a GROMACS selection (default: Backbone)
2) Fit and center the trajectory on the selected atoms (gmx trjconv)
3) Compute covariance matrix and eigenvectors (gmx covar)
4) Analyze eigenvectors and project trajectory (gmx anaeig)
5) Parse .xvg outputs and generate plots

Requirements:
- GROMACS in PATH (gmx) or provide --gmx-bin
- Python packages: numpy, matplotlib

Tested with GROMACS 2021+ selection syntax.
"""

from __future__ import annotations

import argparse
import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import List, Optional, Tuple

import numpy as np

# Matplotlib is optional at import to allow --no-plots on headless systems
try:
    import matplotlib
    matplotlib.use("Agg")  # headless-safe backend
    import matplotlib.pyplot as plt
except Exception as e:
    plt = None  # defer error until we actually try to plot


class CommandError(RuntimeError):
    pass


# Global variable to store the command log script path
_command_script_path: Optional[Path] = None


def set_command_script_path(path: Path) -> None:
    """Set the global path for logging commands."""
    global _command_script_path
    _command_script_path = path
    # Initialize the script with a header
    with path.open("w", encoding="utf-8") as f:
        f.write("#!/bin/bash\n")
        f.write("# GROMACS PCA analysis commands\n")
        f.write("# Generated by gromacs_pca.py\n")
        f.write(f"# Date: {Path(__file__).stat().st_mtime}\n")
        f.write("#\n")
        f.write("# This script reproduces all GROMACS commands executed by the Python script.\n")
        f.write("# You can run this independently to get the same results.\n")
        f.write("#\n\n")
        f.write("set -e  # Exit on error\n\n")


def log_command_to_script(script_path: Path, cmd: List[str], stdin: Optional[str] = None, comment: Optional[str] = None) -> None:
    """Append a command to the reproducibility script.
    
    Args:
        script_path: Path to the shell script file
        cmd: Command tokens
        stdin: Input to be piped to the command
        comment: Optional comment describing the step
    """
    with script_path.open("a", encoding="utf-8") as f:
        if comment:
            f.write(f"\n# {comment}\n")
        
        # Build the command string
        cmd_str = " ".join(f"'{arg}'" if " " in arg else arg for arg in cmd)
        
        if stdin:
            # Use heredoc for multi-line input or echo for simple input
            stdin_clean = stdin.rstrip()
            if "\n" in stdin_clean:
                # Use heredoc for multiple lines
                f.write(f"{cmd_str} <<'EOF'\n{stdin_clean}\nEOF\n")
            else:
                # Use echo for single line
                f.write(f"echo '{stdin_clean}' | {cmd_str}\n")
        else:
            f.write(f"{cmd_str}\n")


def run_cmd(cmd: List[str], stdin: Optional[str] = None, cwd: Optional[Path] = None, comment: Optional[str] = None) -> subprocess.CompletedProcess:
    """Run a command and raise on non-zero return code. Capture stdout/stderr.

    Args:
        cmd: List of command tokens
        stdin: Optional string to feed to stdin (e.g., group selections "0\n0\n")
        cwd: Working directory
        comment: Optional comment for the command log
    Returns:
        CompletedProcess
    Raises:
        CommandError on failure
    """
    # Log to reproducibility script if path is set
    global _command_script_path
    if _command_script_path:
        log_command_to_script(_command_script_path, cmd, stdin, comment)
    
    proc = subprocess.run(
        cmd,
        input=stdin.encode() if stdin is not None else None,
        cwd=str(cwd) if cwd else None,
        check=False,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
    )
    if proc.returncode != 0:
        raise CommandError(f"Command failed ({proc.returncode}): {' '.join(cmd)}\nOutput:\n{proc.stdout.decode(errors='ignore')}")
    return proc


def which_gmx(user_bin: Optional[str]) -> str:
    """Find the GROMACS binary to use (gmx or gmx_mpi).

    Priority:
    1) --gmx-bin argument
    2) $GMX_BIN env var
    3) 'gmx' in PATH
    4) 'gmx_mpi' in PATH
    """
    candidates: List[Optional[str]] = [
        user_bin,
        os.environ.get("GMX_BIN"),
        shutil.which("gmx"),
        shutil.which("gmx_mpi"),
    ]
    for c in candidates:
        if c and shutil.which(c) or (c and Path(c).exists() and os.access(c, os.X_OK)):
            return c
    raise FileNotFoundError(
        "No GROMACS binary found. Install GROMACS or provide --gmx-bin or set $GMX_BIN."
    )


def ensure_outdir(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)


def parse_xvg(xvg_path: Path) -> np.ndarray:
    """Parse a GROMACS .xvg file into a numpy array.

    Ignores lines starting with '@' and '#'.
    Returns an (N, M) float array.
    """
    data: List[List[float]] = []
    with xvg_path.open("r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            line = line.strip()
            if not line or line[0] in ("@", "#"):
                continue
            # Split on whitespace; tolerate multiple spaces/tabs
            parts = line.split()
            try:
                row = [float(x) for x in parts]
            except ValueError:
                # skip any non-numeric line silently
                continue
            data.append(row)
    if not data:
        raise ValueError(f"No numeric data parsed from {xvg_path}")
    return np.array(data, dtype=float)


def plot_eigenvalues(eigvals: np.ndarray, out: Path) -> None:
    if plt is None:
        raise RuntimeError("Matplotlib not available to create plots.")
    # eigvals expected shape (N, 2?) or 1D; robustly handle columns
    vals = eigvals[:, -1] if eigvals.ndim == 2 and eigvals.shape[1] > 1 else eigvals.squeeze()
    idx = np.arange(1, len(vals) + 1)
    plt.figure(figsize=(6, 4))
    plt.plot(idx, vals, marker='o')
    plt.xlabel('Principal Component')
    plt.ylabel('Eigenvalue (variance)')
    plt.title('Scree plot (Eigenvalues)')
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(out.with_suffix('.png'), dpi=200)
    plt.savefig(out.with_suffix('.pdf'))
    plt.close()


def plot_cumulative_variance(eigvals: np.ndarray, out: Path) -> None:
    if plt is None:
        raise RuntimeError("Matplotlib not available to create plots.")
    vals = eigvals[:, -1] if eigvals.ndim == 2 and eigvals.shape[1] > 1 else eigvals.squeeze()
    total = np.sum(vals)
    if total <= 0:
        total = 1.0
    frac = vals / total
    cum = np.cumsum(frac)
    idx = np.arange(1, len(vals) + 1)
    plt.figure(figsize=(6, 4))
    plt.plot(idx, cum, marker='o')
    plt.xlabel('Number of PCs')
    plt.ylabel('Cumulative variance explained')
    plt.title('Cumulative variance')
    plt.ylim(0, 1.05)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(out.with_suffix('.png'), dpi=200)
    plt.savefig(out.with_suffix('.pdf'))
    plt.close()


def plot_pc_scatter(proj: np.ndarray, out: Path, color_by_time: bool = True) -> None:
    if plt is None:
        raise RuntimeError("Matplotlib not available to create plots.")
    # Expect columns: time, PC1, PC2, ... (or possibly just PC1, PC2 without time)
    # Handle various cases
    if proj.shape[1] < 2:
        raise ValueError(f"Projection file must have at least 2 columns for scatter plot, got {proj.shape[1]}")
    
    if proj.shape[1] == 2:
        # Only 2 columns: could be (time, PC1) or (PC1, PC2)
        # Check if first column looks like time (monotonically increasing, reasonable range)
        col0_increasing = np.all(np.diff(proj[:, 0]) >= 0)
        col0_range = proj[-1, 0] - proj[0, 0]
        
        if col0_increasing and col0_range > 10:
            # Likely (time, PC1) - cannot make PC1 vs PC2 scatter
            raise ValueError("Projection file has only time and PC1. Need both PC1 and PC2 for scatter plot.")
        else:
            # Treat as (PC1, PC2)
            pc1 = proj[:, 0]
            pc2 = proj[:, 1]
            t = np.arange(len(pc1))
    elif proj.shape[1] >= 3:
        # Has time column and at least PC1, PC2
        t = proj[:, 0]
        pc1 = proj[:, 1]
        pc2 = proj[:, 2]
    else:
        raise ValueError(f"Cannot create scatter plot from {proj.shape[1]} columns")
    
    plt.figure(figsize=(5, 5))
    if color_by_time and proj.shape[1] >= 3:
        sc = plt.scatter(pc1, pc2, c=t, cmap='viridis', s=10, linewidths=0, alpha=0.8)
        cbar = plt.colorbar(sc)
        cbar.set_label('Time (ps)')
    else:
        plt.scatter(pc1, pc2, s=10, linewidths=0, alpha=0.8)
    plt.xlabel('PC1')
    plt.ylabel('PC2')
    plt.title('PC1 vs PC2 projection')
    plt.tight_layout()
    plt.savefig(out.with_suffix('.png'), dpi=200)
    plt.savefig(out.with_suffix('.pdf'))
    plt.close()


def plot_pc_timeseries(proj: np.ndarray, out: Path, pc_label: str = "PC1") -> None:
    if plt is None:
        raise RuntimeError("Matplotlib not available to create plots.")
    
    if proj.shape[1] < 1:
        raise ValueError(f"Projection file must have at least 1 column, got {proj.shape[1]}")
    
    # Projection file from gmx anaeig -proj typically has format:
    # Column 0: time (ps)
    # Column 1: PC projection value
    
    # So: time is X-axis, PC value is Y-axis
    if proj.shape[1] == 1:
        # Only one column - treat as PC values, use frame index as time
        t = np.arange(len(proj))
        pc_val = proj[:, 0]
        xlabel = 'Frame'
    else:
        # Multiple columns: column 0 is time, column 1 is PC value
        t = proj[:, 0]
        pc_val = proj[:, 1]
        xlabel = 'Time (ps)'
    
    plt.figure(figsize=(6, 3.5))
    plt.plot(t, pc_val, lw=1)
    plt.xlabel(xlabel)
    plt.ylabel(f'{pc_label} projection')
    plt.title(f'{pc_label} projection over time')
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(out.with_suffix('.png'), dpi=200)
    plt.savefig(out.with_suffix('.pdf'))
    plt.close()


def build_index_with_select(gmx: str, s: Path, selection: str, out_ndx: Path, log_dir: Path) -> None:
    cmd = [gmx, "select", "-s", str(s), "-select", selection, "-on", str(out_ndx)]
    proc = run_cmd(cmd, comment=f"Step 1: Build selection index for '{selection}'")
    (log_dir / "select.log").write_bytes(proc.stdout)


def trj_fit_center(gmx: str, s: Path, f: Path, ndx: Path, out_xtc: Path, pbc: str, center: bool, fit: str, log_dir: Path) -> Path:
    """Run trjconv in multiple steps to handle PBC and fitting separately.
    
    Step 0: Create a structure file with selected atoms only (from original TPR + original traj)
    Step 1: PBC treatment + centering, output only selected atoms
    Step 2: Fitting using the structure that matches the filtered trajectory
    
    Returns the filtered structure (GRO) that matches the output trajectory atoms.
    """
    temp_xtc = out_xtc.parent / "temp_pbc.xtc"
    out_gro = out_xtc.parent / "fit.gro"
    
    # Step 0: Create matching structure file FIRST (from original traj with original TPR)
    # This extracts first frame with selected atoms only
    cmd_gro = [gmx, "trjconv", "-s", str(s), "-f", str(f), "-o", str(out_gro), "-n", str(ndx), "-dump", "0"]
    proc_gro = run_cmd(cmd_gro, stdin="0\n", comment="Step 2a: Extract first frame with selected atoms to create reference structure")
    (log_dir / "trjconv_gro.log").write_bytes(proc_gro.stdout)
    
    # Step 1: PBC treatment, centering, output selected atoms only
    cmd1 = [gmx, "trjconv", "-s", str(s), "-f", str(f), "-o", str(temp_xtc), "-n", str(ndx), "-pbc", pbc, "-ur", "compact"]
    if center:
        cmd1.append("-center")
    
    answers1 = ["0"]
    if center:
        answers1 = ["0", "0"]
    stdin1 = "\n".join(answers1) + "\n"
    proc1 = run_cmd(cmd1, stdin=stdin1, comment="Step 2b: PBC treatment and centering")
    (log_dir / "trjconv_pbc.log").write_bytes(proc1.stdout)
    
    # Step 2: Rotational fit using the matching structure
    if fit:
        cmd2 = [gmx, "trjconv", "-s", str(out_gro), "-f", str(temp_xtc), "-o", str(out_xtc), "-fit", fit]
        # No index needed here since out_gro already has only selected atoms
        # Just need to specify fit group (all atoms = 0 = System) and output group (0)
        stdin2 = "0\n0\n"
        proc2 = run_cmd(cmd2, stdin=stdin2, comment="Step 2c: Rotational+translational fitting")
        (log_dir / "trjconv_fit.log").write_bytes(proc2.stdout)
        temp_xtc.unlink()
    else:
        # No fitting, just rename temp to final
        temp_xtc.rename(out_xtc)
        (log_dir / "trjconv_fit.log").write_text("Skipped (no fitting requested)\n")
    
    return out_gro


def run_covar(gmx: str, s: Path, f: Path, out_dir: Path, log_dir: Path) -> Tuple[Path, Path, Path]:
    ev_xvg = out_dir / "eigenvalues.xvg"
    ev_trr = out_dir / "eigenvectors.trr"
    avg_pdb = out_dir / "average.pdb"
    cmd = [
        gmx,
        "covar",
        "-s",
        str(s),
        "-f",
        str(f),
        "-o",
        str(ev_xvg),
        "-v",
        str(ev_trr),
        "-av",
        str(avg_pdb),
    ]
    # covar asks for analysis and fitting groups; since we already filtered,
    # we use group 0 (System, which is all atoms in the filtered structure)
    proc = run_cmd(cmd, stdin="0\n0\n", comment="Step 3: Compute covariance matrix and eigenvectors")
    (log_dir / "covar.log").write_bytes(proc.stdout)
    return ev_xvg, ev_trr, avg_pdb


def run_anaeig(gmx: str, s: Path, f: Path, eig_trr: Path, out_dir: Path, first: int, last: int, log_dir: Path) -> Tuple[Path, Path, Path, Path]:
    proj_xvg = out_dir / "projection.xvg"
    proj_pc1_xvg = out_dir / "projection_pc1.xvg"
    proj_pc2_xvg = out_dir / "projection_pc2.xvg"
    eig_xvg = out_dir / "eig.xvg"
    rmsf_xvg = out_dir / "rmsf.xvg"
    comp_xvg = out_dir / "comp.xvg"
    
    # Run anaeig for PC1 separately
    cmd_pc1 = [
        gmx,
        "anaeig",
        "-s",
        str(s),
        "-f",
        str(f),
        "-v",
        str(eig_trr),
        "-first",
        "1",
        "-last",
        "1",
        "-proj",
        str(proj_pc1_xvg),
    ]
    proc1 = run_cmd(cmd_pc1, stdin="0\n0\n", comment="Step 4a: Project trajectory on PC1")
    (log_dir / "anaeig_pc1.log").write_bytes(proc1.stdout)
    
    # Run anaeig for PC2 separately
    cmd_pc2 = [
        gmx,
        "anaeig",
        "-s",
        str(s),
        "-f",
        str(f),
        "-v",
        str(eig_trr),
        "-first",
        "2",
        "-last",
        "2",
        "-proj",
        str(proj_pc2_xvg),
    ]
    proc2 = run_cmd(cmd_pc2, stdin="0\n0\n", comment="Step 4b: Project trajectory on PC2")
    (log_dir / "anaeig_pc2.log").write_bytes(proc2.stdout)
    
    # Run anaeig for RMSF (full range)
    cmd_rmsf = [
        gmx,
        "anaeig",
        "-s",
        str(s),
        "-f",
        str(f),
        "-v",
        str(eig_trr),
        "-first",
        str(first),
        "-last",
        str(last),
        "-rmsf",
        str(rmsf_xvg),
    ]
    proc_rmsf = run_cmd(cmd_rmsf, stdin="0\n0\n", comment=f"Step 4c: Compute RMSF for PC{first}-PC{last}")
    (log_dir / "anaeig_rmsf.log").write_bytes(proc_rmsf.stdout)
    
    # Return PC1 projection as the main one (for backward compat)
    return proj_pc1_xvg, eig_xvg, rmsf_xvg, comp_xvg


def main(argv: Optional[List[str]] = None) -> int:
    p = argparse.ArgumentParser(description="Automate GROMACS PCA and produce plots.")
    p.add_argument("-s", "--structure", required=True, help="Structure/topology file (TPR recommended; can be TPR/GRO/PDB)")
    p.add_argument("-f", "--trajectory", required=True, help="Trajectory file (XTC/TRR)")
    p.add_argument("-o", "--outdir", default="pca_out", help="Output directory (default: pca_out)")
    p.add_argument("--selection", default="Backbone", help="GROMACS selection text to define atoms (default: Backbone)")
    p.add_argument("--first", type=int, default=1, help="First eigenvector index to analyze (default: 1)")
    p.add_argument("--last", type=int, default=2, help="Last eigenvector index to analyze (default: 2)")
    p.add_argument("--pbc", default="mol", choices=["no", "mol", "res", "atom"], help="PBC handling for trjconv (default: mol)")
    p.add_argument("--no-center", action="store_true", help="Do not center trajectory")
    p.add_argument("--fit", default="rot+trans", choices=["", "none", "rot+trans", "progressive"], help="Fitting mode for trjconv (default: rot+trans). Use 'none' or '' to disable.")
    p.add_argument("--gmx-bin", default=None, help="GROMACS binary to use (e.g., gmx or full path)")
    p.add_argument("--no-plots", action="store_true", help="Skip plotting (still runs GROMACS steps)")
    p.add_argument("--overwrite", action="store_true", help="Overwrite existing outputs if present")

    args = p.parse_args(argv)

    # Resolve paths
    s = Path(args.structure).expanduser().resolve()
    f = Path(args.trajectory).expanduser().resolve()
    outdir = Path(args.outdir).expanduser().resolve()
    ensure_outdir(outdir)
    log_dir = outdir / "logs"
    ensure_outdir(log_dir)
    
    # Initialize command logging script
    command_script = outdir / "commands.sh"
    set_command_script_path(command_script)

    # Basic checks
    if not s.exists():
        print(f"Error: structure file not found: {s}", file=sys.stderr)
        return 2
    if not f.exists():
        print(f"Error: trajectory file not found: {f}", file=sys.stderr)
        return 2

    try:
        gmx = which_gmx(args.gmx_bin)
    except FileNotFoundError as e:
        print(str(e), file=sys.stderr)
        return 2

    # Prepare selection index
    ndx = outdir / "selection.ndx"
    if ndx.exists() and not args.overwrite:
        print(f"[skip] Using existing index: {ndx}")
    else:
        print(f"[1/5] Building selection index with: {args.selection}")
        build_index_with_select(gmx, s, args.selection, ndx, log_dir)

    # Fit/center trajectory
    fit_xtc = outdir / "fit.xtc"
    fit_gro = outdir / "fit.gro"
    do_center = not args.no_center
    fit_mode = None if args.fit in ("", "none") else args.fit

    if fit_xtc.exists() and not args.overwrite:
        print(f"[skip] Using existing fitted trajectory: {fit_xtc}")
        # Ensure we have the matching structure
        if not fit_gro.exists():
            print(f"Warning: {fit_gro} not found, recreating...")
            cmd_gro = [gmx, "trjconv", "-s", str(s), "-f", str(fit_xtc), "-o", str(fit_gro), "-n", str(ndx), "-dump", "0"]
            run_cmd(cmd_gro, stdin="0\n")
    else:
        print("[2/5] Fitting and centering trajectory (trjconv)...")
        fit_gro = trj_fit_center(gmx, s, f, ndx, fit_xtc, args.pbc, do_center, fit_mode, log_dir)

    # PCA: covar (use filtered structure that matches the trajectory, NO index needed)
    print("[3/5] Running covariance analysis (covar)...")
    ev_xvg, ev_trr, avg_pdb = run_covar(gmx, fit_gro, fit_xtc, outdir, log_dir)

    # PCA: anaeig (use filtered structure that matches the trajectory, NO index needed)
    print("[4/5] Analyzing eigenvectors and projecting (anaeig)...")
    proj_xvg, eig_xvg, rmsf_xvg, comp_xvg = run_anaeig(
        gmx, fit_gro, fit_xtc, ev_trr, outdir, args.first, args.last, log_dir
    )

    # Plotting
    if args.no_plots:
        print("[5/5] Skipping plotting as requested (--no-plots)")
        return 0

    if plt is None:
        print("Matplotlib not available; cannot create plots. Install matplotlib or use --no-plots.", file=sys.stderr)
        return 3

    print("[5/5] Parsing XVG files and generating plots...")
    try:
        eig_data = parse_xvg(ev_xvg)
        plot_eigenvalues(eig_data, outdir / "plot_eigenvalues")
        plot_cumulative_variance(eig_data, outdir / "plot_cumulative_variance")
    except Exception as e:
        print(f"Warning: failed eigenvalue plots: {e}")

    try:
        proj_pc1_data = parse_xvg(outdir / "projection_pc1.xvg")
        proj_pc2_data = parse_xvg(outdir / "projection_pc2.xvg")
        print(f"  PC1 projection shape: {proj_pc1_data.shape}")
        print(f"  PC2 projection shape: {proj_pc2_data.shape}")
        print(f"  PC1 range: {proj_pc1_data[:, 1].min():.3f} to {proj_pc1_data[:, 1].max():.3f}")
        print(f"  PC2 range: {proj_pc2_data[:, 1].min():.3f} to {proj_pc2_data[:, 1].max():.3f}")
        
        # Verify they have the same number of frames
        if proj_pc1_data.shape[0] != proj_pc2_data.shape[0]:
            print(f"  ERROR: PC1 has {proj_pc1_data.shape[0]} frames but PC2 has {proj_pc2_data.shape[0]} frames!")
            raise ValueError("PC1 and PC2 projections have different numbers of frames")
        
        # Verify time columns match
        if not np.allclose(proj_pc1_data[:, 0], proj_pc2_data[:, 0]):
            print("  Warning: Time columns don't match between PC1 and PC2!")
        
        # Combine PC1 and PC2 for scatter plot: columns = [time, PC1, PC2]
        combined_proj = np.column_stack([proj_pc1_data[:, 0], proj_pc1_data[:, 1], proj_pc2_data[:, 1]])
        print(f"  Combined data shape for scatter: {combined_proj.shape}")
        print(f"  First few rows of combined [time, PC1, PC2]:")
        print(f"{combined_proj[:3]}")
        
        plot_pc_scatter(combined_proj, outdir / "plot_pc1_pc2_scatter", color_by_time=True)
        plot_pc_timeseries(proj_pc1_data, outdir / "plot_pc1_timeseries", pc_label="PC1")
        plot_pc_timeseries(proj_pc2_data, outdir / "plot_pc2_timeseries", pc_label="PC2")
        print(f"  Plots saved successfully")
    except Exception as e:
        print(f"Warning: failed projection plots: {e}")
        import traceback
        traceback.print_exc()

    print("Done. Outputs in:", outdir)
    print()
    print(f"All GROMACS commands have been logged to: {command_script}")
    print("You can re-run the analysis independently with:")
    print(f"  chmod +x {command_script}")
    print(f"  {command_script}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
