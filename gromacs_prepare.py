#!/usr/bin/env python3
"""
GROMACS Automation Script with command-line arguments and logging
Usage: python gromacs_prepare.py <pdb_file> [options]
"""

import argparse
import subprocess
import sys
import os
from pathlib import Path
from datetime import datetime

# Global variable to store the command log script path
_command_script_path = None

def set_command_script_path(path):
    """Set the global path for logging commands."""
    global _command_script_path
    _command_script_path = path
    # Initialize the script with a header
    with open(path, 'w') as f:
        f.write("#!/bin/bash\n")
        f.write("# GROMACS preparation pipeline commands\n")
        f.write("# Generated by gromacs_prepare.py\n")
        f.write("#\n")
        f.write("# This script reproduces all GROMACS commands executed by the Python script.\n")
        f.write("# You can run this independently to get the same results.\n")
        f.write("#\n\n")
        f.write("set -e  # Exit on error\n\n")

def log_command_to_script(command, comment=None):
    """Append a command to the reproducibility script."""
    global _command_script_path
    if _command_script_path is None:
        return
    
    with open(_command_script_path, 'a') as f:
        if comment:
            f.write(f"\n# {comment}\n")
        f.write(f"{command}\n")

def run_gromacs_command(command, description, log_filename):
    """Run a GROMACS command, capture output to log file, and handle errors"""
    print(f"\n{'='*50}")
    print(f"Running: {description}")
    print(f"Command: {command}")
    print(f"Log file: {log_filename}")
    print(f"{'='*50}")
    
    # Log to reproducibility script
    log_command_to_script(command, description)
    
    # Write command and timestamp to log file
    with open(log_filename, 'w') as log_file:
        log_file.write(f"GROMACS Automation Log\n")
        log_file.write(f"Tool: {description}\n")
        log_file.write(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        log_file.write(f"Command: {command}\n")
        log_file.write(f"{'='*60}\n\n")
    
    try:
        # Run command and capture both stdout and stderr
        result = subprocess.run(command, shell=True, check=True, 
                              capture_output=True, text=True)
        
        # Append output to log file
        with open(log_filename, 'a') as log_file:
            if result.stdout:
                log_file.write("STDOUT:\n")
                log_file.write(result.stdout)
                log_file.write("\n")
            if result.stderr:
                log_file.write("STDERR:\n")
                log_file.write(result.stderr)
                log_file.write("\n")
            log_file.write(f"\nReturn code: {result.returncode}\n")
            log_file.write("âœ“ Command completed successfully\n")
        
        print("âœ“ Success!")
        return True
        
    except subprocess.CalledProcessError as e:
        # Append error information to log file
        with open(log_filename, 'a') as log_file:
            if e.stdout:
                log_file.write("STDOUT:\n")
                log_file.write(e.stdout)
                log_file.write("\n")
            if e.stderr:
                log_file.write("STDERR:\n")
                log_file.write(e.stderr)
                log_file.write("\n")
            log_file.write(f"\nReturn code: {e.returncode}\n")
            log_file.write("âœ— Command failed!\n")
        
        print(f"âœ— Error running {description}:")
        print(f"Check log file: {log_filename}")
        print(f"Return code: {e.returncode}")
        return False

def get_solvent_group_number(tpr_file):
    """Get the group number for solvent (SOL) from the TPR using gmx make_ndx.

    Returns the numeric group id as a string (e.g., '13') if found, else None.
    """
    try:
        result = subprocess.run(f"gmx make_ndx -f {tpr_file} -o index.ndx", 
                                shell=True, check=True, 
                                input="q\n", capture_output=True, text=True)
        output = result.stdout
        for line in output.splitlines():
            if "SOL" in line:
                parts = line.split()
                if parts and parts[0].isdigit():
                    return parts[0]
    except subprocess.CalledProcessError as e:
        print("Error determining solvent group number.")
    return None

def automate_gromacs(args):
    """Automate GROMACS preparation steps for MD simulations.

    Parameters
    ----------
    args : argparse.Namespace
        Parsed command-line arguments containing at least:
        pdb_file, forcefield, water_model, box_type, box_distance,
        solvent_file, cation, anion.
    """
    # Initialize command logging script
    commands_file = Path.cwd() / "commands.sh"
    set_command_script_path(commands_file)
    print(f"\nAll GROMACS commands will be logged to: {commands_file}")

    # Derive stem from input pdb file
    input_pdb_path = Path(args.pdb_file)
    stem = input_pdb_path.stem

    # Step 1: pdb2gmx
    topology_file = f"{stem}.top"
    gro_output = f"{stem}.gro"
    pdb2gmx_log = f"{stem}_pdb2gmx.log"
    pdb2gmx_cmd = (
        f"gmx pdb2gmx -f {args.pdb_file} -o {gro_output} -p {topology_file} "
        f"-ff {args.forcefield} -water {args.water_model}"
    )
    if not run_gromacs_command(pdb2gmx_cmd, "pdb2gmx", pdb2gmx_log):
        return False

    # Step 2: editconf (define box)
    box_output = f"{stem}_box.gro"
    editconf_log = f"{stem}_editconf.log"
    editconf_cmd = (
        f"gmx editconf -f {gro_output} -o {box_output} -c -d {args.box_distance} "
        f"-bt {args.box_type}"
    )
    if not run_gromacs_command(editconf_cmd, "editconf", editconf_log):
        return False

    # Step 3: solvate
    solvent_output = f"{stem}_solvent.gro"
    solvate_log = f"{stem}_solvate.log"
    solvate_cmd = (
        f"gmx solvate -cp {box_output} -cs {args.solvent_file} -o {solvent_output} "
        f"-p {topology_file}"
    )
    if not run_gromacs_command(solvate_cmd, "solvate", solvate_log):
        return False

    # Step 4: prepare for ion addition (minimal mdp + grompp)
    with open("minimal.mdp", "w") as f:
        f.write("integrator = md\n")
        f.write("dt = 0.001\n")
        f.write("nsteps = 1\n")

    grompp_log = f"{stem}_grompp.log"
    tpr_file = f"{stem}_ions.tpr"
    grompp_cmd = (
        f"gmx grompp -f minimal.mdp -c {solvent_output} -p {topology_file} -o {tpr_file}"
    )
    if not run_gromacs_command(grompp_cmd, "grompp", grompp_log):
        return False

    # Step 5: genion (determine solvent group dynamically)
    ions_output = f"{stem}_ions.gro"
    genion_log = f"{stem}_genion.log"
    solvent_group_number = get_solvent_group_number(tpr_file)
    if not solvent_group_number:
        print("Error: Could not detect SOL group in index (from make_ndx). Aborting.")
        return False

    # Build genion command with optional neutralization
    neutral_flag = "" if getattr(args, "no_neutral", False) else " -neutral"
    genion_cmd = (
        f"echo {solvent_group_number} | gmx genion -s {tpr_file} -o {ions_output} -p {topology_file} "
        f"-pname {args.cation} -nname {args.anion}{neutral_flag}"
    )
    if not run_gromacs_command(genion_cmd, "genion", genion_log):
        return False

    # Cleanup temporary files
    for temp_file in ["minimal.mdp", "mdout.mdp", tpr_file]:
        if os.path.exists(temp_file):
            os.remove(temp_file)

    # Summary
    print(f"\n{'='*60}")
    print("âœ“ GROMACS AUTOMATION COMPLETED SUCCESSFULLY!")
    print(f"{'='*60}")
    print("Final output files:")
    print(f"- Topology: {topology_file}")
    print(f"- Final structure: {ions_output}")
    print(f"- Intermediate structures: {box_output}, {solvent_output}")
    print("\nLog files:")
    print(f"- pdb2gmx: {pdb2gmx_log}")
    print(f"- editconf: {editconf_log}")
    print(f"- solvate: {solvate_log}")
    print(f"- grompp: {grompp_log}")
    print(f"- genion: {genion_log}")
    return True

def main():
    parser = argparse.ArgumentParser(description="Automate GROMACS preprocessing pipeline")
    parser.add_argument("pdb_file", help="Input PDB file")
    parser.add_argument("-ff", "--forcefield", default="charmm27", help="Force field (default: charmm27)")
    parser.add_argument("-d", "--box-distance", type=float, default=1.0, help="Distance to box wall in nm (default: 1.0)")
    parser.add_argument("-bt", "--box-type", default="cubic", help="Box type (default: cubic)")
    parser.add_argument("-cs", "--solvent-file", default="spc216.gro", help="Solvent model file (default: spc216.gro)")
    parser.add_argument("-wm", "--water-model", default="tip3p", help="Water model for pdb2gmx (default: tip3p)")
    parser.add_argument("-pname", "--cation", default="NA", help="Cation type (default: NA)")
    parser.add_argument("-nname", "--anion", default="CL", help="Anion type (default: CL)")
    parser.add_argument("--no-neutral", action="store_true", help="Do not add neutralizing ions (omit -neutral in genion)")
    
    args = parser.parse_args()
    
    if not os.path.exists(args.pdb_file):
        print(f"Error: PDB file '{args.pdb_file}' not found!")
        sys.exit(1)
    
    success = automate_gromacs(args)
    
    if not success:
        print("\nðŸ’¥ Pipeline failed! Check the log files above for details.")
        sys.exit(1)

if __name__ == "__main__":
    main()

